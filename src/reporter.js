export function createReporter(config) {
  return {
    generate({ findings, actions, chunks, auditorCost, auditorModel, focusAreas, duration, exitCode }) {
      const durationMin = Math.round(duration / 60000);
      const now = new Date().toISOString();

      // Count by severity
      const counts = { CRITICAL: 0, WARNING: 0, INFO: 0, SUGGESTION: 0 };
      for (const f of findings) {
        counts[f.severity] = (counts[f.severity] || 0) + 1;
      }

      // Count actions by type
      const actionCounts = {};
      for (const a of actions) {
        actionCounts[a.type] = (actionCounts[a.type] || 0) + 1;
      }

      // Build report
      const lines = [];

      lines.push('# Audit Report');
      lines.push('');
      lines.push(`**Generated**: ${now}`);
      lines.push(`**Duration**: ${durationMin} minutes`);
      lines.push(`**Auditor model**: ${auditorModel} | **Auditor cost**: $${auditorCost.toFixed(4)}`);
      if (focusAreas.length > 0) {
        lines.push(`**Focus areas**: ${focusAreas.join(', ')}`);
      }
      lines.push(`**Autonomy**: ${config.autonomy}`);
      lines.push(`**Exit code**: ${exitCode}`);
      lines.push('');

      // Summary
      lines.push('## Summary');
      lines.push('');
      lines.push(`- ${counts.CRITICAL} critical finding${counts.CRITICAL !== 1 ? 's' : ''}`);
      lines.push(`- ${counts.WARNING} warning${counts.WARNING !== 1 ? 's' : ''}`);
      lines.push(`- ${counts.INFO} info finding${counts.INFO !== 1 ? 's' : ''}`);
      lines.push(`- ${counts.SUGGESTION} suggestion${counts.SUGGESTION !== 1 ? 's' : ''}`);
      lines.push('');

      if (Object.keys(actionCounts).length > 0) {
        lines.push('### Supervisor Actions');
        lines.push('');
        for (const [type, count] of Object.entries(actionCounts)) {
          lines.push(`- ${type}: ${count}`);
        }
        lines.push('');
      }

      // Findings by severity
      if (findings.length > 0) {
        lines.push('## Findings');
        lines.push('');

        for (const severity of ['CRITICAL', 'WARNING', 'INFO', 'SUGGESTION']) {
          const group = findings.filter(f => f.severity === severity);
          if (group.length === 0) continue;

          lines.push(`### ${severity}`);
          lines.push('');

          group.forEach((f, i) => {
            const ts = new Date(f.timestamp).toLocaleTimeString('en-US', { hour12: false });
            lines.push(`${i + 1}. **[${ts}]** ${f.description}`);
          });

          lines.push('');
        }
      } else {
        lines.push('## Findings');
        lines.push('');
        lines.push('No findings were identified during this session.');
        lines.push('');
      }

      // Supervisor action log
      if (actions.length > 0) {
        lines.push('## Action Log');
        lines.push('');

        for (const a of actions) {
          const ts = new Date(a.timestamp).toLocaleTimeString('en-US', { hour12: false });
          const auto = a.autoApproved ? ' (auto)' : '';
          lines.push(`- **[${ts}] [${a.type}${auto}]** ${a.message}`);
        }

        lines.push('');
      }

      // Session statistics
      lines.push('## Session Statistics');
      lines.push('');
      lines.push(`- Total chunks analyzed: ${chunks.totalChunks}`);
      lines.push(`- Total lines processed: ${chunks.totalLines}`);

      if (Object.keys(chunks.detectedTools).length > 0) {
        const toolList = Object.entries(chunks.detectedTools)
          .map(([tool, count]) => `${tool}: ${count}`)
          .join(', ');
        lines.push(`- Tool calls observed: ${toolList}`);
      }

      lines.push('');
      lines.push('---');
      lines.push('*Generated by [claude-auditor](https://github.com/claude-auditor/claude-auditor)*');

      return lines.join('\n');
    },
  };
}
